You are an expert in financial reconciliation systems, React, TypeScript, Vite, Tailwind CSS, shadcn/ui, Supabase, and Vercel serverless functions.

## Project: ReconcileX — AI-Powered Financial Reconciliation SaaS

## Key Principles
- Write concise, type-safe TypeScript code with explicit return types
- Use functional components and React hooks exclusively
- Feature-based folder structure under src/features/
- Define types/interfaces BEFORE implementation
- All matching logic must be configurable and rule-based
- Always read ARCHITECTURE.md before making changes to understand the system
- Never modify the matching engine logic without explicit instructions
- Prefer composition over inheritance

## Domain Context
ReconcileX automates financial reconciliation for Shared Service Centers:
- Users upload 2 CSV/Excel files (Source A and Source B)
- System normalizes data quality issues (whitespace, dates, amounts, vendor names)
- Users configure matching rules with weights (amount, date, reference, vendor name)
- Matching engine scores all potential pairs and assigns best matches
- Results show matched pairs, unmatched items, and detected anomalies
- AI features: exception analysis, copilot chat, natural language rules, smart suggestions

## Tech Stack
- Frontend: React 18 + TypeScript + Vite 7
- Styling: Tailwind CSS 4 + shadcn/ui components
- Auth: Supabase Auth (email/password) with organization-based multi-tenancy
- Database: Supabase PostgreSQL with Row Level Security (RLS)
- Storage: Supabase Storage (bucket: reconciliation-files) for large dataset transport
- API: Vercel Serverless Functions (TypeScript, /api directory)
- AI: Anthropic Claude (claude-sonnet-4-20250514) for AI features
- Parsing: PapaParse (CSV) + SheetJS/xlsx (Excel)
- Charts: Recharts
- Icons: Lucide React

## 3-Tier Matching Architecture
The system uses 3 tiers based on dataset size. Tier routing is automatic in serverMatching.ts. ReconciliationFlowPage.tsx does NOT know which tier is used.

Tier 1 Client-Side (less than 1500 total rows): matchingEngine.ts runs directly in browser via useMatching hook. Instant results, no server calls.

Tier 2 Vercel Direct (1500 to 30000 total rows): serverMatching.ts serializes data to CSV text via serializeToCsv(). POST /api/match with CSV in body (3x smaller than JSON). Vercel function maxDuration 300s, 1024MB memory. api/match.ts parses CSV, runs matching engine, returns full results.

Tier 3 Storage Transport (30000+ total rows): serverMatching.ts uploads CSV to Supabase Storage bucket. Creates signed URLs (5 min expiry) and sends only URLs to /api/match. api/match.ts downloads CSVs from signed URLs, runs matching. Returns INDEX-BASED response (not full transaction objects) to stay under 4.5MB response limit. Frontend reconstructs full ReconciliationResult from local data plus indices. Temporary files deleted from Storage after processing.

## Matching Engine Optimizations
- Binary search pre-filter: sorts B by amount, uses binary search to find candidates within tolerance
- Optimized Levenshtein: single-row dynamic programming with early termination
- Similarity cache: pre-computed for datasets with less than 50K unique pairs
- Skip cache mode for more than 50K pairs to save memory

## Project Structure
reconcilex/
  api/ — Vercel serverless functions
    match.ts — Server-side matching (Tier 2 and 3)
    analyze.ts — AI exception analysis
    copilot.ts — Reconciliation Copilot
    nl-rules.ts — Natural Language to MatchingConfig
    normalize.ts — AI normalization suggestions
  src/
    App.tsx — Router
    main.tsx — Entry point with AuthProvider and ErrorBoundary
    contexts/AuthContext.tsx — Supabase auth plus organizationId
    lib/
      supabase.ts — Supabase client
      database.ts — All DB functions
      errorMessages.ts — Friendly error message mapper
      utils.ts — cn() utility
    pages/
      ReconciliationFlowPage.tsx — 5-step orchestrator
      DashboardPage.tsx
      HistoryPage.tsx
      TemplatesPage.tsx
      SettingsPage.tsx
      SecurityPage.tsx
    features/
      upload/ — File upload (drag and drop, CSV/Excel)
      normalization/ — Smart Data Normalization
      preview/ — Side-by-side data preview
      matching-rules/ — Rule configuration plus smart suggestions
      nl-rules/ — Natural Language AI Rule Builder
      reconciliation/
        engine/matchingEngine.ts — Shared matching engine (client)
        services/serverMatching.ts — Server matching service (Tier 2 and 3)
        hooks/useMatching.ts — Client matching hook (Tier 1)
        utils/parseCsv.ts — CSV parser plus serializeToCsv
        types.ts — All shared types
      results/ — Results with pagination
      anomalies/ — Client-side anomaly detection
      copilot/ — Slide-out AI chat
      patterns/ — Pattern learning system
    components/
      ui/ — shadcn/ui components
      ErrorBoundary.tsx — Global error boundary

## API Conventions
- All Vercel functions in /api directory (standalone, NOT Next.js)
- Each function is self-contained — no imports from src/ (Vercel limitation)
- Matching engine code is DUPLICATED in api/match.ts (cannot import from src/)
- Use export const config = { maxDuration: 300 } for timeout
- Return proper HTTP status codes with JSON error messages

## Database Conventions
- All tables have RLS enabled
- All queries filter by organization_id via RLS policies
- Use organization_members table to link users to orgs
- Storage bucket reconciliation-files has RLS by org folder path

## File Naming
- Components: PascalCase (TransactionList.tsx)
- Hooks: camelCase with use prefix (useMatching.ts)
- Utils/services: camelCase (parseAmount.ts, serverMatching.ts)
- Types: PascalCase in types.ts files
- API: camelCase (match.ts, analyze.ts)
- Pages: PascalCase with Page suffix (DashboardPage.tsx)

## Code Style
- Always use TypeScript strict mode
- Prefer const over let, never var
- Use early returns to reduce nesting
- Extract complex logic into custom hooks
- All components must have typed Props interfaces
- Use getFriendlyErrorMessage() for user-facing errors
- Use console.log with [module] prefix for debugging e.g. [serverMatching]
- Pagination for any table or list that could exceed 100 items

## Design System

### Branding
- Keep sidebar logo and subtitle as-is

### Colors (Updated)
- --app-bg: #F8FAFC (Stripe-style warm white)
- --app-bg-shell: #F1F5F9 (page shell behind sidebar — softer)
- --app-sidebar: #0F172A (deep slate)
- --app-primary: #2563EB (blue — unchanged)
- --app-ai-accent: #7C3AED (violet — AI features)
- --app-ai-accent-light: #EDE9FE (violet light bg)
- --app-success: #059669
- --app-body: #64748B (slightly lighter for softer contrast)
- --app-border: #E2E8F0

### Fonts (Updated)
- --font-heading: "Inter", system-ui, sans-serif (weight 600-700)
- --font-body: "Inter", system-ui, sans-serif (weight 400-500)
- Google Fonts import: Inter weights 400, 500, 600, 700

### Component Patterns (Updated)
- Cards: bg-white rounded-2xl border border-slate-200/60 shadow-[0_1px_3px_0_rgb(0,0,0,0.04)]
- Cards hover: hover:shadow-[0_4px_12px_0_rgb(0,0,0,0.06)] transition-shadow
- Buttons primary: bg-[--app-primary] rounded-lg px-4 py-2.5 shadow-sm active:scale-[0.98]
- Buttons secondary: bg-white border-slate-200 rounded-lg
- Table headers: bg-slate-50 (not bg-white) text-xs uppercase tracking-wider text-slate-500
- Table rows: py-4 px-5 hover:bg-slate-50/50 border-b border-slate-100
- Section headers: text-sm font-semibold tracking-wide uppercase text-[var(--app-heading)] — NO navy bg blocks (only sidebar uses dark)
- Stat numbers: text-4xl font-semibold tabular-nums
- Stat labels: text-xs font-medium uppercase tracking-wider text-[--app-body]
- AI features: Dark bg (slate-900), violet accents, Sparkles icon
- Status badges: pill style — bg-emerald-50 text-emerald-700 rounded-full
- Sidebar active: bg-white/10 text-white rounded-lg
- Page spacing: mb-8 between major sections, p-6 inside cards, gap-5 for grids
- Stepper: h-10 w-10 blue circles, ring-4 ring-blue-100 on current step, bg-slate-200 connectors for incomplete
- Upload dropzones: border-2 border-dashed border-slate-200 rounded-2xl p-8, emerald success state (bg-emerald-50/50 border-emerald-200)
- Matching type cards: selected = border-2 border-[var(--app-primary)] bg-blue-50/30
- Rule cards: bg-white rounded-2xl border-slate-200/60 shadow, inline dropdowns + sliders

### AI Rule Builder
- Dark card: bg-gradient-to-br from-slate-900 to-slate-800
- Violet radial gradient decoration
- Input: bg-white/10 backdrop-blur border-white/10
- Button: bg-violet-500 with Sparkles icon
- Pills: bg-white/10 text-white/70 rounded-full

### Results Page UI Patterns
- Tabs: pill-style — bg-slate-100 container, bg-white active tab, no navy
- Table headers: bg-slate-50 (not bg-white)
- Summary cards: premium card styling with emerald match rate colors

### General
- All interactive elements must have cursor-pointer
- Disabled elements: cursor-not-allowed with reduced opacity
- Do NOT use --app-primary-dark or navy #1E3A5F for headers (deprecated)

## Critical Rules
- NEVER send raw user financial data to logs or third parties
- ALWAYS clean up temporary Storage files after matching (finally block)
- NEVER exceed Vercel 4.5MB body limit — use Storage transport for large payloads
- ALWAYS maintain backward compatibility when changing api/match.ts (3 input formats)
- Matching engine changes must be applied to BOTH matchingEngine.ts AND api/match.ts
- Test with: npx tsc -b --noEmit (must show 0 errors)
