You are an expert in financial reconciliation systems, React, TypeScript, Vite, Tailwind CSS, shadcn/ui, Supabase, and Vercel serverless functions.

## Project: ReconcileX — AI-Powered Financial Reconciliation SaaS

## Key Principles
- Write concise, type-safe TypeScript code with explicit return types
- Use functional components and React hooks exclusively
- Feature-based folder structure under src/features/
- Define types/interfaces BEFORE implementation
- All matching logic must be configurable and rule-based
- Always read ARCHITECTURE.md before making changes to understand the system
- Never modify the matching engine logic without explicit instructions
- Prefer composition over inheritance

## Domain Context
ReconcileX automates financial reconciliation for Shared Service Centers:
- Users upload 2 CSV/Excel files (Source A and Source B)
- System normalizes data quality issues (whitespace, dates, amounts, vendor names)
- Users configure matching rules with weights (amount, date, reference, vendor name)
- Matching engine scores all potential pairs and assigns best matches
- Results show matched pairs, unmatched items, and detected anomalies
- AI features: exception analysis, copilot chat, natural language rules, smart suggestions

## Tech Stack
- Frontend: React 18 + TypeScript + Vite 7
- Styling: Tailwind CSS 4 + shadcn/ui components
- Auth: Supabase Auth (email/password) with organization-based multi-tenancy
- Database: Supabase PostgreSQL with Row Level Security (RLS)
- Storage: Supabase Storage (bucket: reconciliation-files) for large dataset transport
- API: Vercel Serverless Functions (TypeScript, /api directory)
- AI: Anthropic Claude (claude-sonnet-4-20250514) for AI features
- Parsing: PapaParse (CSV) + SheetJS/xlsx (Excel)
- Charts: Recharts
- Icons: Lucide React

## 3-Tier Matching Architecture
The system uses 3 tiers based on dataset size. Tier routing is automatic in serverMatching.ts. ReconciliationFlowPage.tsx does NOT know which tier is used.

Tier 1 Client-Side (less than 1500 total rows): matchingEngine.ts runs directly in browser via useMatching hook. Instant results, no server calls.

Tier 2 Vercel Direct (1500 to 30000 total rows): serverMatching.ts serializes data to CSV text via serializeToCsv(). POST /api/match with CSV in body (3x smaller than JSON). Vercel function maxDuration 300s, 1024MB memory. api/match.ts parses CSV, runs matching engine, returns full results.

Tier 3 Storage Transport (30000+ total rows): serverMatching.ts uploads CSV to Supabase Storage bucket. Creates signed URLs (5 min expiry) and sends only URLs to /api/match. api/match.ts downloads CSVs from signed URLs, runs matching. Returns INDEX-BASED response (not full transaction objects) to stay under 4.5MB response limit. Frontend reconstructs full ReconciliationResult from local data plus indices. Temporary files deleted from Storage after processing.

## Matching Engine Optimizations
- Binary search pre-filter: sorts B by amount, uses binary search to find candidates within tolerance
- Optimized Levenshtein: single-row dynamic programming with early termination
- Similarity cache: pre-computed for datasets with less than 50K unique pairs
- Skip cache mode for more than 50K pairs to save memory

## Project Structure
reconcilex/
  api/ — Vercel serverless functions
    match.ts — Server-side matching (Tier 2 and 3)
    analyze.ts — AI exception analysis
    copilot.ts — Reconciliation Copilot
    nl-rules.ts — Natural Language to MatchingConfig
    normalize.ts — AI normalization suggestions
  src/
    App.tsx — Router
    main.tsx — Entry point with AuthProvider and ErrorBoundary
    contexts/AuthContext.tsx — Supabase auth plus organizationId
    lib/
      supabase.ts — Supabase client
      database.ts — All DB functions
      errorMessages.ts — Friendly error message mapper
      utils.ts — cn() utility
    pages/
      ReconciliationFlowPage.tsx — 5-step orchestrator
      DashboardPage.tsx
      HistoryPage.tsx
      TemplatesPage.tsx
      SettingsPage.tsx
      SecurityPage.tsx
    features/
      upload/ — File upload (drag and drop, CSV/Excel)
      normalization/ — Smart Data Normalization
      preview/ — Side-by-side data preview
      matching-rules/ — Rule configuration plus smart suggestions
      nl-rules/ — Natural Language AI Rule Builder
      reconciliation/
        engine/matchingEngine.ts — Shared matching engine (client)
        services/serverMatching.ts — Server matching service (Tier 2 and 3)
        hooks/useMatching.ts — Client matching hook (Tier 1)
        utils/parseCsv.ts — CSV parser plus serializeToCsv
        types.ts — All shared types
      results/ — Results with pagination
      anomalies/ — Client-side anomaly detection
      copilot/ — Slide-out AI chat
      patterns/ — Pattern learning system
    components/
      ui/ — shadcn/ui components
      ErrorBoundary.tsx — Global error boundary

## API Conventions
- All Vercel functions in /api directory (standalone, NOT Next.js)
- Each function is self-contained — no imports from src/ (Vercel limitation)
- Matching engine code is DUPLICATED in api/match.ts (cannot import from src/)
- Use export const config = { maxDuration: 300 } for timeout
- Return proper HTTP status codes with JSON error messages

## Database Conventions
- All tables have RLS enabled
- All queries filter by organization_id via RLS policies
- Use organization_members table to link users to orgs
- Storage bucket reconciliation-files has RLS by org folder path

## File Naming
- Components: PascalCase (TransactionList.tsx)
- Hooks: camelCase with use prefix (useMatching.ts)
- Utils/services: camelCase (parseAmount.ts, serverMatching.ts)
- Types: PascalCase in types.ts files
- API: camelCase (match.ts, analyze.ts)
- Pages: PascalCase with Page suffix (DashboardPage.tsx)

## Code Style
- Always use TypeScript strict mode
- Prefer const over let, never var
- Use early returns to reduce nesting
- Extract complex logic into custom hooks
- All components must have typed Props interfaces
- Use getFriendlyErrorMessage() for user-facing errors
- Use console.log with [module] prefix for debugging e.g. [serverMatching]
- Pagination for any table or list that could exceed 100 items

## Design System

### Branding
- Keep sidebar logo and subtitle as-is

### Colors
- --app-sidebar: #1E3A5F (warm navy) — sidebar bg
- --app-bg-shell: #E8E8E8 — page shell behind sidebar and content
- --app-bg: #FAFAFA — content area background
- --app-primary: #2563EB (blue) — links, active tabs, progress indicators
- --app-heading: #0F172A — headings, primary text
- --app-body: #475569 — body text, labels, secondary text
- --app-border: #E2E8F0 — borders
- --app-success: #059669 — success states
- AI accent coral: #E8475C — AI Rule Builder "Create Rules" button
- Emerald indicators: text-emerald-500 for match rates, sparklines, positive changes

### Fonts
- --font-heading: "Inter", system-ui, sans-serif (weight 600-700)
- --font-body: "Inter", system-ui, sans-serif (weight 400-500)

### Dashboard Stat Cards
- Labels: Title Case (not UPPERCASE), text-sm text-[--app-body]
- Numbers: text-3xl font-bold text-[var(--app-heading)]
- Match Rate indicator: "△33%" in emerald-500 next to number
- Sparklines: inline SVG, emerald-400 stroke, 80x32px
- Secondary info: text-xs text-emerald-500

### AI Rule Builder
- Two-column layout: teal gradient illustration (left ~280px) + white content (right)
- Illustration: bg-gradient-to-br from-[#0D9488] to-[#115E59] with CSS geometric shapes + glowing dots
- "Create Rules" button: bg-[#E8475C] coral (NOT violet, NOT navy)
- Suggestion pills: bg-white border-slate-200 rounded-full
- Input: bg-slate-50 border-slate-200 rounded-xl

### Recent Reconciliations Table
- "RECENT RECONCILIATIONS" header: bold uppercase inside the card
- Table headers: regular weight, title case, text-[--app-body]
- Match Rate: "△ 89% ✓" in emerald-500
- Status: plain green text "Complete", no badge/pill
- "View all >" at bottom-left of card

### Sidebar
- Background: #1E3A5F (warm navy, NOT slate-900)
- Active item: bg-white/15 rounded-lg
- Nav text: white/70 inactive, white active
- Bottom: user name, email, sign out, "AI Powered" badge

### Top Bar
- Avatar: ring-2 ring-[#2563EB] ring-offset-2

### Page Shell
- Background: #E8E8E8

### Component Patterns (other)
- Cards: bg-white rounded-2xl border border-slate-200/60 shadow-[0_1px_3px_0_rgb(0,0,0,0.04)]
- Stepper: h-10 w-10 blue circles, ring-4 ring-blue-100 on current step, bg-slate-200 connectors for incomplete
- Upload dropzones: border-2 border-dashed border-slate-200 rounded-2xl p-8, emerald success state
- Matching type cards: selected = border-2 border-[var(--app-primary)] bg-blue-50/30
- Rule cards: bg-white rounded-2xl border-slate-200/60 shadow, inline dropdowns + sliders
- Results page: pill-style tabs, bg-slate-50 table headers, premium summary cards
- Page spacing: mb-6 between major sections (compact, professional)

### General
- All interactive elements must have cursor-pointer
- Disabled elements: cursor-not-allowed with reduced opacity

## Critical Rules
- NEVER send raw user financial data to logs or third parties
- ALWAYS clean up temporary Storage files after matching (finally block)
- NEVER exceed Vercel 4.5MB body limit — use Storage transport for large payloads
- ALWAYS maintain backward compatibility when changing api/match.ts (3 input formats)
- Matching engine changes must be applied to BOTH matchingEngine.ts AND api/match.ts
- Test with: npx tsc -b --noEmit (must show 0 errors)
